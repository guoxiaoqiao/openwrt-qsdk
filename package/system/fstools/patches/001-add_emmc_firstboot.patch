--- a/dev/null
+++ b/libfstools/ext4.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <sys/mount.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <asm/byteorder.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <mtd/mtd-user.h>
+#include <glob.h>
+
+#include "libfstools.h"
+
+#include "volume.h"
+
+#define ext4_sysfs_path "/sys/block/mmcblk*/mmcblk*/uevent"
+#define PATH_MAX	128
+
+struct ext4_priv {
+	char	*name;
+        char    *devname;
+};
+
+static struct driver ext4_driver;
+
+static int ext4_volume_init(struct volume *v)
+{
+	char buf[PATH_MAX];
+	struct ext4_priv *p;
+
+	p = (struct ext4_priv*)v->priv;
+	snprintf(buf, sizeof(buf), "/dev/%s",p->devname);
+
+	v->name = strdup(p->name);
+	v->type = 5;
+	v->blk = strdup(buf);
+	return 0;
+}
+
+static int ext4_find_index(char *dev,char *name)
+{
+	int j;
+	FILE *fp;
+	char tmp[PATH_MAX];
+	char partname[PATH_MAX];
+	glob_t gl;
+
+	if (glob(ext4_sysfs_path, GLOB_NOESCAPE | GLOB_MARK, NULL, &gl) < 0)
+		return -1;
+
+	for (j = 0; j < gl.gl_pathc; j++) {
+		if ((fp = fopen(gl.gl_pathv[j], "r"))) {
+			 while(fgets(tmp, sizeof(tmp), fp))  {
+				if(strstr(tmp, "DEVNAME"))  {
+					strcpy(partname,tmp+strlen("DEVNAME="));
+				}
+				if(strstr(tmp,name))  {
+					partname[sizeof(partname) - 1] = '\0';
+					j = strlen(partname) - 1;
+					while (j > 0 && partname[j] <= ' ')
+						partname[j--] = '\0';
+					strcpy(dev,partname);
+					fclose(fp);
+					globfree(&gl);
+					return 0;
+				}
+			}
+			fclose(fp);
+		}
+	}
+	globfree(&gl);
+	return -1;
+}
+
+static int ext4_volume_find(struct volume *v, char *name)
+{
+	char buf[PATH_MAX];
+	struct ext4_priv *p;
+
+	if (find_filesystem("ext4"))
+		return -1;
+
+	if(ext4_find_index(buf,name))
+		return -1;
+
+        p = calloc(1, sizeof(struct ext4_priv));
+        if (!p)
+                return -1;
+
+        v->priv = p;
+        v->drv = &ext4_driver;
+
+        p->devname = strdup(buf);
+        p->name = strdup(name);
+        return ext4_volume_init(v);
+}
+
+static int ext4_volume_identify(struct volume *v)
+{
+	return FS_EXT4FS;
+}
+
+static struct driver ext4_driver = {
+        .name = "ext4",
+        .find = ext4_volume_find,
+        .init = ext4_volume_init,
+        .identify = ext4_volume_identify,
+};
+DRIVER(ext4_driver);
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -11,6 +11,7 @@
 		libfstools/overlay.c
 		libfstools/volume.c
 		libfstools/mtd.c
+		libfstools/ext4.c
 		libfstools/mount.c
 		libfstools/ubi.c
 		libfstools/find.c)
--- a/mount_root.c
+++ b/mount_root.c
@@ -62,6 +62,7 @@
 
 	case FS_JFFS2:
 	case FS_UBIFS:
+	case FS_EXT4FS:
 		mount_overlay(data);
 		break;
 
@@ -96,6 +97,7 @@
 	switch (volume_identify(v)) {
 	case FS_NONE:
 	case FS_DEADCODE:
+	case FS_EXT4FS:
 		return jffs2_switch(v);
 	}
 
--- a/libfstools/libfstools.h
+++ b/libfstools/libfstools.h
@@ -25,6 +25,7 @@
 	FS_JFFS2,
 	FS_DEADCODE,
 	FS_UBIFS,
+	FS_EXT4FS,
 };
 
 extern char const *extroot_prefix;
--- a/libfstools/overlay.c
+++ b/libfstools/overlay.c
@@ -54,7 +54,7 @@
 static int
 overlay_mount(struct volume *v, char *fs)
 {
-	if (mkdir("/tmp/overlay", 0755)) {
+	if (mkdir("/tmp/overlay", 0755) && errno != EEXIST) {
 		fprintf(stderr, "failed to mkdir /tmp/overlay: %s\n", strerror(errno));
 		return -1;
 	}
@@ -146,6 +146,7 @@
 jffs2_switch(struct volume *v)
 {
 	char *mp;
+	char buf[32];
 	int ret = -1;
 
 	if (find_overlay_mount("overlayfs:/tmp/root"))
@@ -195,6 +196,18 @@
 			ret = -1;
 		}
 		break;
+
+	case FS_EXT4FS:
+		snprintf(buf,sizeof(buf),"mkfs.ext4 %s",v->blk);
+		system(buf);
+		ret = overlay_mount(v, "ext4");
+		if (ret)
+			break;
+		if (mount_move("/tmp", "", "/overlay") || fopivot("/overlay", "/rom")) {
+			fprintf(stderr, "switching to ext4 failed\n");
+			ret = -1;
+		}
+		break;
 	}
 	return ret;
 }
@@ -214,6 +227,9 @@
 	case FS_UBIFS:
 		fstype = "ubifs";
 		break;
+	case FS_EXT4FS:
+		fstype = "ext4";
+		break;
 	}
 
 	if (mount(v->blk, "/tmp/overlay", fstype, MS_NOATIME, NULL)) {
